from z3 import *

#result_7= [0x00,0x7, 0xb2,0x70,0xb9,0xa,0xd2,0x71,0xdf,0x05,0xa,0x71,0x6b,0x0a,0xa8,0x7a,0x7a,0x0,0x86,0x7c,0xa7,0x01,0x45,0x78,0x7b,0x0c,0xb2,0x79,0x33,0xf,0x1e,0x71]
result_7= [0x703,0x40b2,0xabd,0x31d2,0x5e3,0x310a,0xa6f,0x3aa8,0x7e,0x3c86,0x1ab,0x3845,0xc7f,0x39b2,0xf37,0x311e]
#[0x706,0x10b2,0xabf,0x11d2,0x5e5,0x110a,0xa71,0x1aa8,0x80,0x1c86,0x1ad,0x1845,0xc81,0x19b2,0xf39,0x111e]
#0x704,0x30b2,0xabe,0x21d2,0x5e4,0x210a,0xa70,0x2aa8,0x7f,0x2c86,0x1ac,0x2845,0xc80,0x29b2,0xf38,0x211e
0x705,0x20b2,0xabf,0x11d2,0x5e5,0x110a,0xa71,0x1aa8,0x80,0x1c86,0x1ad,0x1845,0xc81,0x19b2,0xf39,0x111e

#a_140=[0x140,0x140,0x140,0x140,0x140,0x140,0x140,0x140,0x140,0x140,0x140,0x140,0x140,0x140,0x140,0x140]

v_140=[0x40,0x01,0x40,0x01,0x40,0x01,0x40,0x01,0x40,0x01,0x40,0x01,0x40,0x01,0x40,0x01,0x40,0x01,0x40,0x01,0x40,0x01,0x40,0x01,0x40,0x01,0x40,0x01,0x40,0x01,0x40,0x01]

#note that the FF means doesnt matter because the shuffle would ignore them anyway 
X1 = [ Int('x%s' % i) for i in range(32) ]

#x=Int('x')
#y=Int('y')

s=Solver()



s.add( (X1[0] * v_140[0]) +(X1[1] * v_140[1] ) ==0x705, X1[0]<=0xFF, X1[1]<=0xFF , (X1[0] * v_140[0])<0xFFFF , (X1[1] * v_140[1] ) <0xFFFF)
s.add( (X1[2] * v_140[2]) +(X1[3] * v_140[3] ) ==0x20b2 , X1[2]<=0xFF, X1[3]<=0xFF, (X1[2] * v_140[2]) <0xFFFF, (X1[3] * v_140[3] ) <0xFFFF)
s.add( (X1[4] * v_140[4]) +(X1[5] * v_140[5] ) ==0xabf , X1[4]<=0xFF, X1[5]<=0xFF , (X1[4] * v_140[4]) <0xFFFF, (X1[5] * v_140[5] ) <0xFFFF)
s.add( (X1[6] * v_140[6]) +(X1[7] * v_140[7] ) ==0x11d2 , X1[6]<=0xFF, X1[7]<=0xFF , (X1[6] * v_140[6]) <0xFFFF, (X1[7] * v_140[7] ) <0xFFFF)
s.add( (X1[8] * v_140[8]) +(X1[9] * v_140[9] ) ==0x5e5, X1[8]<=0xFF, X1[9]<=0xFF, (X1[8] * v_140[8]) <0xFFFF, (X1[9] * v_140[9] ) <0xFFFF)
s.add( (X1[10] * v_140[10]) +(X1[11] * v_140[11] ) ==0x110a,  X1[10]<=0xFF, X1[11]<=0xFF , (X1[10] * v_140[10]) <0xFFFF, (X1[11] * v_140[11] ) <0xFFFF)
s.add( (X1[12] * v_140[12]) +(X1[13] * v_140[13] ) ==0xa71,  X1[12]<=0xFF, X1[13]<=0xFF, (X1[12] * v_140[12]) <0xFFFF, (X1[13] * v_140[13] )<0xFFFF)
s.add( (X1[14] * v_140[14]) +(X1[15] * v_140[15] ) ==0x1aa8, X1[14]<=0xFF, X1[15]<=0xFF, (X1[14] * v_140[14]) <0xFFFF, (X1[15] * v_140[15] ) <0xFFFF)
s.add( (X1[16] * v_140[16]) +(X1[17] * v_140[17] ) ==0x80,  X1[16]<=0xFF, X1[17]<=0xFF, (X1[16] * v_140[16]) <0xFFFF , (X1[17] * v_140[17] )<0xFFFF )
s.add( (X1[18] * v_140[18]) +(X1[19] * v_140[19] ) ==0x1c86, X1[18]<=0xFF, X1[19]<=0xFF, (X1[18] * v_140[18]) <0xFFFF ,(X1[19] * v_140[19] )<0xFFFF  )
s.add( (X1[20] * v_140[20]) +(X1[21] * v_140[21] ) ==0x1ad,  X1[20]<=0xFF, X1[21]<=0xFF, (X1[20] * v_140[20]) <0xFFFF ,(X1[21] * v_140[21] ) <0xFFFF )
s.add( (X1[22] * v_140[22]) +(X1[23] * v_140[23] ) ==0x1845,X1[22]<=0xFF, X1[23]<=0xFF, (X1[22] * v_140[22]) <0xFFFF ,(X1[23] * v_140[23] ) <0xFFFF)
s.add( (X1[24] * v_140[24]) +(X1[25] * v_140[25] ) ==0xc81, X1[24]<=0xFF, X1[25]<=0xFF, (X1[24] * v_140[24]) <0xFFFF ,(X1[25] * v_140[25] )<0xFFFF )
s.add( (X1[26] * v_140[26]) +(X1[27] * v_140[27] ) ==0x19b2, X1[26]<=0xFF, X1[27]<=0xFF, (X1[26] * v_140[26]) <0xFFFF ,(X1[27] * v_140[27] )<0xFFFF)
s.add( (X1[28] * v_140[28]) +(X1[29] * v_140[29] ) ==0xf39,  X1[28]<=0xFF, X1[29]<=0xFF, (X1[28] * v_140[28]) <0xFFFF ,(X1[29] * v_140[29] )<0xFFFF)
s.add( (X1[30] * v_140[30]) +(X1[31] * v_140[31] ) ==0x111e, X1[30]<=0xFF, X1[31]<=0xFF, (X1[30] * v_140[30]) <0xFFFF ,(X1[31] * v_140[31] )<0xFFFF)


while s.check() == sat:
  print s.model()
  for i in range(0,16):
   s.add((X1[i] != s.model()[X1[i]]))



#[x8 = 114, x12 = 3187, x2 = 2737, x14 = 3883, x10 = 415, x4 = 1495, x6 = 2659, x0 = 1784, #0x6f8 x15  61726, x13 = 63922, x11 = 63557, x9 = 64646,x7 = 64168,x5 = 61706,x3 = 61906,x1 = 61618]

#[0x6f8,0xf0b2,0xab1,0xf1d2, 0x5d7, 61706,2659,64168, 114,64646,415,63557,3187,63922,3883,61726, ]

#result_before vpmaddwd
#a=[0xf8,0x06,0xb2,0xf0,0xb1,0xa,0xd2,0xf1,0xd7,0x5,0x0a,0xf1,0x63,0x0a,0xa8,0xfa,0x72,0x00,0x86,0xfc,0x9f,0x01,0x45,0xf8,0x73,0xc,0xb2,0xf9,0x2b,0xf,0x1e,0xf1]
#the above have signed bytes so wont work. this one below will work

#result_7=[0x00,0x7, 0xb2,0x70,0xb9,0xa,0xd2,0x71,0xdf,0x05,0xa,0x71,0x6b,0x0a,0xa8,0x7a,0x7a,0x0,0x86,0x7c,0xa7,0x01,0x45,0x78,0x7b,0x0c,0xb2,0x79,0x33,0xf,0x1e,0x71]

print s.check()
while s.check() == sat:
  print s.model()
  for i in range(0,16):
   s.add((X1[i] != s.model()[X1[i]]))



#result_6= 
# problem with above result is that in vpmaddsubsw the intermmediate multiplied value can be signed and it s treated as signed word while adding. so we need to place the restriction that we get a valu after multiplication that is <0x80000

#after placing the above constraint we get the below result which works perfectly 
#result_6= 0x19,0xc3,0xff,0xf2,0x27,0xfd,0xc4,0xd2,0x14,0xe3,0xc1,0xca,0x26,0xef,0xe7,0xe8,0x0,0x7e,0xef,0xc6,0x3,0xeb,0xde,0xc5,0x2e,0xff,0xe3,0xf2,0x39,0xf7,0xc1,0xde
